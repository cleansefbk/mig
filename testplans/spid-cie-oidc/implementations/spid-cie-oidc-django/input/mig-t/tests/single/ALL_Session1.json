{
  "test suite": {
    "name": "Session_1",
    "description": "All the entities and the available patterns: ",
    "filter messages": true
  },
  "tests": [
    {
      "test": {
        "name": "Does the AA metadata contain the authorization_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the authorization_endpoint claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.authorization_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the contacts claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain dpop_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the dpop_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.dpop_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the federation_trust_mark_status_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the grant_types_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the grant_types_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.grant_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the homepage_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the issuer claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the issuer claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.issuer",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the jwks claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the jwks claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the logo_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the op_policy_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the op_policy_uri claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.op_policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the op_tos_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the op_tos_uri claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.op_tos_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the organization_name claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the policy_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the resource claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the resource claim in the 'oauth_resource' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_resource.resource",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the response_types_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the response_types_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.response_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the scopes_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the scopes_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.scopes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the token_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the token_endpoint claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the token_endpoint_auth_methods_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the token_endpoint_auth_methods_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the token_endpoint_auth_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct dpop_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the dpop_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is 'one_of': ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.dpop_signing_alg_values_supported.one_of",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the token_endpoint_auth_methods_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the token_endpoint_auth_methods_supported claim in the 'oauth_authorization_server' entity type is checked. It must contain the key-value pair 'one_of': ['private_key_jwt']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_methods_supported.one_of",
                    "is in": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the token_endpoint_auth_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked to be 'one_of': ['RS256', 'RS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_signing_alg_values_supported.one_of",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_AA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain op_policy_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the op_policy_uri claim in the 'openid_provider' entity type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata.openid_provider.op_policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA's entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration of the AA is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain incorrect dpop_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the dpop_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.dpop_signing_alg_values_supported.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain incorrect token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the token_endpoint_auth_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_signing_alg_values_supported.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type authorization_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the authorization_endpoint claim in the 'federation_entity' entity type is \"private\"",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"authorization_endpoint\": {\"type\": \"string\",\"const\": \"private\"}},\"required\": [\"authorization_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type logo_uri claim",
        "description": "In this test the SA metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type op_policy_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the op_policy_uri claim in the 'openid_provider' entity type is \"private\"",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"op_policy_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"op_policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type resource claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the resource claim in the 'federation_entity' entity type is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"resource\": {\"oneOf\": [{\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"},{\"type\": \"array\",\"items\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"},\"minItems\": 1}]}},\"required\": [\"resource\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain a correct type of issuer claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the issuer claim in the 'oauth_authorization_server' entity type is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"issuer\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"issuer\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain a correct logo_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the logo_uri claim is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"logo_uri\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA's entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration of the AA is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response AA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response AA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response AA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response AA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response AA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_key_AA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim is 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks[0].trust_mark.organization_type",
                    "is in": [
                      "public",
                      "private"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim is 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.organization_type",
                    "is in": [
                      "public",
                      "private"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain a correct sa_profile claim",
        "description": "A Trust Mark issued for an SA is taken, decrypted and the value of the sa_profile claim can be 'full' or 'light'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sa_profile",
                        "is in": [
                          "light",
                          "full"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain a correct sa_profile claim",
        "description": "A Trust Mark issued for an SA is taken, decrypted and the value of the sa_profile claim can be 'full' or 'light'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sa_profile",
                        "is in": [
                          "light",
                          "full"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Anchor's Entity configuration's constraints parameter contain the attribute 'max_path_length'",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked. It must contain the attribute max_path_length",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints.max_path_length",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the contacts parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'contacts' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the federation_fetch_endpoint parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'federation_fetch_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_fetch_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the federation_list_endpoint parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'federation_list_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_list_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the federation_resolve_endpoint parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'federation_resolve_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the federation_trust_mark_status_endpoint parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'federation_trust_mark_status_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the homepage_uri parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'homepage_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the logo_uri parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'logo_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the organization_name parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'organization_name' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the policy_uri parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'policy_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the authorization_response_iss_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_response_iss_parameter_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported.value",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the claims_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the claims_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct claims_parameter_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the claims_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported.value",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the client_registration_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct client_registration_types_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the client_registration_types_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct code_challenge_methods_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.code_challenge_methods_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_provider type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_authentication_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_methods_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_methods_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_authentication_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'value'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported.value",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_parameter_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported.value",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_types_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_types_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint_auth_methods_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint_auth_methods_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct subject_types_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.subject_types_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_methods_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.openid_provider.token_endpoint_auth_methods_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the openid_relying_party type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_signed_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct response_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the openid_relying_party type is checked. It must contain the key 'value'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types.value",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the openid_relying_party type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_registration_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.client_registration_types.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_enc parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_enc.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_signed_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct response_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the intermediary type is checked. It must contain the key 'value'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types.value",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct token_endpoint_auth_method parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_method.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_enc parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_enc.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_signed_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct acr_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked. It must contain the value 'subset_of': ['https://www.spid.gov.it/SpidL1', 'https://www.spid.gov.it/SpidL2', 'https://www.spid.gov.it/SpidL3']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.acr_values_supported.subset_of",
                    "is subset of": [
                      "https://www.spid.gov.it/SpidL1",
                      "https://www.spid.gov.it/SpidL2",
                      "https://www.spid.gov.it/SpidL3"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct code_challenge_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it must be valued as ['S256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.code_challenge_methods_supported.subset_of",
                    "is subset of": [
                      "S256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct grant_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it must be valued as ['refresh_token', 'authorization_code']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types_supported.subset_of",
                    "is subset of": [
                      "refresh_token",
                      "authorization_code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_enc_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and must be valued as ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_enc_values_supported.one_of",
                    "is subset of": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it must be valued as ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_signing_alg_values_supported.one_of",
                    "is subset of": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued as ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported.subset_of",
                    "is subset of": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_modes_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it is valued with['form_post', 'query']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_modes_supported.subset_of",
                    "is subset of": [
                      "form_post",
                      "query"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['code']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_types_supported.subset_of",
                    "is subset of": [
                      "code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint_auth_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['private_key_jwt']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint_auth_methods_supported.subset_of",
                    "is subset of": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct scopes_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['openid', 'offline_access', 'profile', 'email']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.scopes_supported.subset_of",
                    "is subset of": [
                      "openid",
                      "offline_access",
                      "profile",
                      "email"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct subject_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['pairwise']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.subject_types_supported.subset_of",
                    "is subset of": [
                      "pairwise"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['private_key_jwt']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.token_endpoint_auth_methods_supported.subset_of",
                    "is subset of": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported.one_of",
                    "is subset of": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported.one_of",
                    "is subset of": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_enc_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_enc_values_supported.one_of",
                    "is subset of": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported.one_of",
                    "is subset of": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['automatic']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types.subset_of",
                    "is subset of": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with '[authorization_code, refresh_token]'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types.subset_of",
                    "is subset of": [
                      "authorization_code",
                      "refresh_token"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg.one_of",
                    "is subset of": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc.one_of",
                    "is subset of": [
                      "A128CBC-HS256\" , \"A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg.one_of",
                    "is subset of": [
                      "RS256\" , \"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct response_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the openid_relying_party type is checked. It must contain the key 'value'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types.value",
                    "is subset of": [
                      "code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['private_key']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method.one_of",
                    "is subset of": [
                      "private_key"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg.one_of",
                    "is subset of": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc.one_of",
                    "is subset of": [
                      "A128CBC-HS256\" , \"A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg.one_of",
                    "is subset of": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_registration_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked. It must contain the key 'one_of' valued with ['automatic']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.client_registration_types.subset_of",
                    "is subset of": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked. It must contain the key 'subset_of' values with ['authorization_code', 'refresh_token']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types.subset_of",
                    "is subset of": [
                      "authorization_code",
                      "refresh_toke"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of': valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg.one_of",
                    "is subset of": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_enc.one_of",
                    "is subset of": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg.one_of",
                    "is subset of": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct response_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the intermediary type is checked. It must contain the key 'value' with value 'code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types.value",
                    "is subset of": [
                      "code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct token_endpoint_auth_method parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked. It must contain the key 'one_of' valued with ['private_key']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_method.one_of",
                    "is subset of": [
                      "private_key"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg.one_of",
                    "is subset of": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_enc.one_of",
                    "is subset of": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg.one_of",
                    "is subset of": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim is a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim has to be a list of JSON Objects",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\":\"object\",\"properties\":{\"email\":{\"type\":\"string\",\"format\":\"email\"}},\"required \":[\"email\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number claim or vat_number in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"fiscal_number\": {}, \"vat_number\":{}},\"anyOf\":[{\"required\":[\"fiscal_number\"]},{\"required\":[\"vat_number\"]}]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by a TA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the ipa_code in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \", \"enum \": [ \"private \", \u00a0\"public \"]}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the policy_uri claim has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the service_documentation has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the tos_uri claim has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim is a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim has to be a list of JSON Objects",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number claim or vat_number in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"fiscal_number\": {}, \"vat_number\":{}},\"anyOf\":[{\"required\":[\"fiscal_number\"]},{\"required\":[\"vat_number\"]}]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by a TA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the ipa_code in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \", \"enum \": [ \"private \", \u00a0\"public \"]}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the policy_uri claim has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the service_documentation has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the tos_uri claim has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA correctly sign the issued Trust Mark",
        "description": "To accomplish this test, a Trust Mark issued by the TA is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA correctly sign the issued Trust Mark",
        "description": "To accomplish this test, a Trust Mark issued by the TA is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_TA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA correctly sign the Entity statements",
        "description": "In order to validate the signature of an Entity statement issued by the TA, the statement is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter of the entity configuration), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_TA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA correctly sign the Entity statements",
        "description": "In order to validate the signature of an Entity statement issued by the TA, the statement is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter of the entity configuration), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_TA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity configuration of the Trust Anchor contain the constraints parameter in its decoded payload",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Federation Configuration contain the TA public keys",
        "description": "The Federation configuration must contain, among others, the TA public keys. To check the presence of those keys, the Entity Configuration is taken from the TA's '.well-known/openid-federation' endpoint and the response is analyzed, in the returned JWT the claim 'jwks' must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does TA's Entity configuration contain the trust_marks_issuers parameter",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks_issuers parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_mark_issuers",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the constraints parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the exp parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the iat parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statement issued by the TA contain the iss parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the jwks parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the sub parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the trust_marks parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the constraints parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the exp parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the iat parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statement issued by the TA contain the iss parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the jwks parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the sub parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the trust_marks parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to be an URL",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to be an URL",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an TA must be taken, decrypted and the presence of the claims claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "The id of the trust mark must be present. So in this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by a TA for public organization contain ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of 'ipa_code' in the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.id_code.ipa_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "The id of the trust mark must be present. So in this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by a TA for a public organization contain ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of 'ipa_code' in the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.id_code.ipa_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sa_profile",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. The key 'subset_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_alg_values_supported.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the id_token_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the request_authentication_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported.subset_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the userinfo_encryption_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. The key 'subset_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the userinfo_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the token_endpoint_auth_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the id_token_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. The key 'subset_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the id_token_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the userinfo_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. The key 'subset_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values in the userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid value for the id_token_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. The key 'subset_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the id_token_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the userinfo_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. The key 'subset_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "body",
                "check regex": "\\[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA correctly release the Entity statements",
        "description": "After a correct onboarding with the TA, it must publish the entity statement for the subordinate entity in its fetch endpoint. So, in this test, once correctly registered an Entity, an HTTP GET request is made to the TA's fetch endpoint, with the request containing the Entity identifier. The response is then checked and it must contain the subordinate entity's Entity Statement.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA correctly release the Entity statements",
        "description": "After a correct onboarding with the TA, it must publish the entity statement for the subordinate entity in its fetch endpoint. So, in this test, once correctly registered an Entity, an HTTP GET request is made to the TA's fetch endpoint, with the request containing the Entity identifier. The response is then checked and it must contain the subordinate entity's Entity Statement.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Fetch Entity Statement response TA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Fetch Entity Statement response TA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA publish the federation public key history",
        "description": "An HTTP Get request is made to the TA's /.well-known/openid-federation-jwks endpoint and the answer is analyzed",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Public Keys History response",
            "checks": [
              {
                "in": "body",
                "check regex": "\\[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Anchor's Entity configuration contain a constraints parameter valued as a JSON Object with a max_path_length claim",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"constraints\": {\"type\": \"object\", \"properties\": {\"max_path_length\": {}}, \"required\": [\"max_path_length\"]}, \"required\": [\"constraints\"]}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain correct type logo_uri claim",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does TA's Entity configuration's trust_mark_issuers parameter contain a JSON Array",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the trust_mark_issuers parameter must be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_mark_issuers\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_mark_issuers\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct acr_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked. It must be a JSON object containing the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.acr_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\":{}, \"superset_of\":{}},\"required\":[\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_response_iss_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' and it must be valued as ['true']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"value\": {\"const\": true}}, \"required\": [\"value\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct claims_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the claims_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' and it must be valued as ['true']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"value\": {\"const\": true}}, \"required\": [\"value\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct client_registration_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the client_registration_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' and it must be valued as ['automatic']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {\"const\": \"automatic\"}}, \"required\": [\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct grant_types_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_enc_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_signing_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_authentication_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' and it must be valued with ['request_object']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"value\": {\"const\": \"request_object\"}}, \"required\": [\"value\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_signing_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_object_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and 'superset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_object_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued as ['RS256', 'RS512'] ",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]} [\"RS256\", \"RS512\"]"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['true']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"value\": {\"const\": true}}, \"required\": [\"value\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_modes_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_modes_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\":{}, \"superset_of\":{}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct scopes_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.scopes_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\":{}, \"superset_of\":{}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_signing_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_enc_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_signing_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct grant_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' and 'superset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\", \"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct grant_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked. It must contain the key 'subset_of' and 'superset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"subset_of\": {}, \"superset_of\": {}}, \"required\": [\"subset_of\"], [\"superset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response TA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response TA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response TA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response TA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response TA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain a correct 'acr_values' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'acr_values' parameter is checked. If it is present, than it must be a string with the requested 'acr' values, each of them separated by a single space. The supported values are 'https://www.spid.gov.it/SpidL1', 'https://www.spid.gov.it/SpidL2' and 'https://www.spid.gov.it/SpidL3'. If it contains other values or it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.acr_values",
                    "is in": [
                      "https://www.spid.gov.it/SpidL1",
                      "https://www.spid.gov.it/SpidL2",
                      "https://www.spid.gov.it/SpidL3",
                      "https://www.spid.gov.it/SpidL1 https://www.spid.gov.it/SpidL2",
                      "https://www.spid.gov.it/SpidL1 https://www.spid.gov.it/SpidL3",
                      "https://www.spid.gov.it/SpidL2 https://www.spid.gov.it/SpidL3",
                      "https://www.spid.gov.it/SpidL1 https://www.spid.gov.it/SpidL2 https://www.spid.gov.it/SpidL3"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'prompt' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the 'prompt' parameter is checked. It must be set to the value 'consent' or 'consent login'. If it contains other values or it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.prompt",
                    "is in": [
                      "consent",
                      "consent login"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request contain a correct value in 'scope' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'scope' parameter must be set to the value 'openid' then it can (optionally) have the values 'offline_access', 'profile' or 'email' appended.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.scope",
                    "is in": [
                      "openid",
                      "openid profile",
                      "openid email",
                      "openid offline_access",
                      "openid offline_access profile",
                      "openid offline_access email"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP use an asymmetric algorithm to sign the JWT in the request parameter of the Authentication Request",
        "description": "In this test the Authentication Request is taken and the alg parameter in the JWT Header is checked. If it corresponds to a symmetric algorithm or it is none, than the RP is not compliant with the specifications.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'client_id' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'client_id' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'client_registration_types' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'client_registration_types' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_registration_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the contacts claim",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the grant_types claim",
        "description": "In this test the RP metadata are taken and the presence of the 'grant_types' parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.grant_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'grant_types' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'grant_types' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.grant_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the homepage_uri claim",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'id_token_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'id_token_encrypted_response_alg' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'id_token_encrypted_response_enc' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'id_token_encrypted_response_enc' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'id_token_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'id_token_signed_response_alg' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'jwks' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'jwks' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'jwks' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'jwks' parameter is checked. If it is absent, than the RP is not compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the logo_uri claim",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the organization_name claim",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the policy_uri claim",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'redirect_uris' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'redirect_uris' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.redirect_uris",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'signed_jwks_uri' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'signed_jwks_uri' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.signed_jwks_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'token_endpoint_auth_method' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'token_endpoint_auth_method' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.token_endpoint_auth_method",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'userinfo_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'userinfo_encrypted_response_alg' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'userinfo_encrypted_response_enc' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'userinfo_encrypted_response_enc' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'userinfo_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'userinfo_signed_response_alg' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'response_types' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'response_types' parameter in the 'openid_relying_party' metadata type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.response_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'client_id' parameter identifying the RP",
        "description": "In this test the request parameter of the Authentication Request is taken, the payload decrypted and the value of the 'client_id' parameter correspond to the one that can be found in the EC of the RP",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.client_id",
                    "as": "client_id"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_id",
                    "contains": "client_id"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'iss' parameter set to the RP's client_id",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'iss' parameter has to be the client_id of the RP. If it is another value or is missing, than the RP is not compliant with the specifications",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_id",
                    "contains": "iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'redirect_uri' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'redirect_uri' parameter matches one of the URLs given in the RP metadata.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.redirect_uri",
                    "as": "redirect_uris"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.redirect_uris",
                    "contains": "redirect_uris"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain a correct 'response_type' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'response_type' parameter is checked. This parameter's value must be the same of the 'response_types_supported' parameter in the OP metadata",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.response_type",
                    "as": "response_types_supported"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.response_types[0]",
                    "contains": "response_types_supported"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the JWT payload contain a correct 'iss' claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking the iss claim. Its value must be an URL identifying the RP",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.metadata.openid_relying_party.client_id",
                    "as": "client_id"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "client_id"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'aud' parameter in the Payload set to RP's 'client_id'",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the value of the 'aud' parameter in the Payload set to the RP's 'client_id'",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "saved_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.aud[0]",
                    "contains": "saved_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'client_registration_types' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'client_registration_types' parameter is 'automatic'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_registration_types[0]",
                    "is in": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct grant_types claim",
        "description": "In this test the RP metadata are taken and the value of the 'grant_types' parameter contains 'authorization_code' and 'refresh_token'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.grant_types[0]",
                    "is in": [
                      "authorization_code",
                      "refresh_token"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'id_token_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_encrypted_response_alg' parameter is ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_alg",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'id_token_encrypted_response_enc' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_encrypted_response_enc' parameter is ['A128CBC-HS256', 'A256CBC-HS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_enc",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'id_token_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_signed_response_alg' parameter is ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_signed_response_alg",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'token_endpoint_auth_method' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'token_endpoint_auth_method' parameter is 'one_of': 'private_key_jwt'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.token_endpoint_auth_method",
                    "is in": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'userinfo_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'userinfo_encrypted_response_alg' parameter is ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_alg",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'userinfo_encrypted_response_enc' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'userinfo_encrypted_response_enc' parameter is ['A128CBC-HS256', 'A256CBC-HS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_enc",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'userinfo_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'userinfo_signed_response_alg' parameter is ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_signed_response_alg",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain in the 'response_types' the value 'code'",
        "description": "In this test the RP metadata are taken and the 'response_types' parameter in the 'openid_relying_party' contains the value 'code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.response_types[0]",
                    "is in": [
                      "code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP's Authentication Request contain the 'code_challenge' parameter",
        "description": "The Authentication request is taken and the presence of the 'code_challenge' parameter is checked. If it is present, than the Authentication Request is using PKCE and is compliant with the specifications, otherwise it is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "code_challenge"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP's Authentication Request contain the 'code_challenge_method' parameter",
        "description": "The Authentication request is taken and the presence of the 'code_challenge_method' parameter is checked. If it is not present, then the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "code_challenge_method"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the client_id parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "client_id"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the response type in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the response_type parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "response_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client_assertion",
        "description": "The Introspection request made by the RP is taken and the presence of the client_assertion parameter is checked.",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client_assertion_type",
        "description": "The Introspection request made by the RP is taken and the presence of the client_assertion_type parameter is checked.",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion_type"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client_assertion as a valid JWT",
        "description": "The Introspection request made by the RP is taken and the value of the client_assertion parameter is a signed JWT structure",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client id of the RP making the request",
        "description": "The Introspection request made by the RP is taken and the presence of the client_id parameter is checked.",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_id"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request use HTTP POST",
        "description": "The Introspection request made by the RP use HTTP POST",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "POST"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the token",
        "description": "The Introspection request made by the RP is taken and the presence of the token parameter is checked.",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "token"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain the client assertion",
        "description": "The Revocation request made by the RP is taken and the presence of the client_assertion parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain the client_assertion_type",
        "description": "The Revocation request made by the RP is taken and the presence of the client_assertion_type parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain the client_id of the RP making the request",
        "description": "The Revocation request made by the RP is taken and the presence of the client_id parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_id"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain the token for which the request is made",
        "description": "The Revocation request made by the RP is taken and the presence of the token parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the client_assertion",
        "description": "The token request sent by the RP must contain client_assertion parameter in the URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the client_assertion_type",
        "description": "The token request sent by the RP must contain client_assertion_type parameter in the URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the client_id",
        "description": "The token request sent by the RP must contain client_id parameter in the URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_id"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the code parameter",
        "description": "The token request sent by the RP must contain code parameter in the URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "code"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the code_verifier parameter",
        "description": "The token request sent by the RP must contain code_verifier parameter in the URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "code_verifier"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the grant_type parameter",
        "description": "The token request sent by the RP must contain grant_type parameter in the URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "grant_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP revoke the Token when the User logs out",
        "description": "In order to test if the RP really revokes an access token on logout, a classic authentication flow is computed and, once obtained the token and used, a logout is performed. After this, the requests made by the RP must be analyzed and there has to be a request to the OP's revocation endpoint for only the access token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP contain the Access Token in the UserInfo request",
        "description": "The UserInfo request from the RP is taken and analyzed. In the Authorization field of the header there must be an Access Token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo request",
            "checks": [
              {
                "in": "head",
                "is present": true,
                "check param": "Authorization"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct type of client_assertion_type",
        "description": "The Introspection request made by the RP is taken and the value of the client_assertion_type parameter is urn:ietf:params:oauth:clientassertion-type:jwt-bearer",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "check": "client_assertion_type",
                "is": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct client id of the RP making the request",
        "description": "The Introspection request made by the RP is taken and the value of the client_id parameter identifies the RP",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "check": "client_id",
                "is": "X_url_RP"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct client_assertion_type",
        "description": "The Revocation request made by the RP is taken and the value of the client_assertion_type parameter is urn:ietf:params:oauth:clientassertion-type:jwt-bearer",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check": "client_assertion_type",
                "is": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_assertion_type parameter in the token request contain the correct type",
        "description": "The client_assertion_type parameter in the URL of the token request sent by the RP must be set to urn:ietf:params:oauth:client-assertion-type:jwtbearer",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check": "client_assertion_type",
                "is": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_id in the token request identifies the RP",
        "description": "The client_id parameter in the URL of the token request is taken. This parameter must identify the RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check": "client_id",
                "is": "X_https_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain a correct grant_type parameter",
        "description": "The grant_type parameter in the URL of the token request sent by the RP must be set to authorization_code or to refresh_token. So in this test a token request is taken and the grant_type parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check regex": "(?<=grant_type=)([^&]+)",
                "is in": [
                  "authorization_code",
                  "refresh_token"
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct client_id of the RP making the request",
        "description": "The Revocation request made by the RP is taken and the value of the client_id parameter is an URI that identifies the RP",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "edit operations": [
              {
                "from": "body",
                "value": "https://example.com",
                "edit regex": "(?<=client_id=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_assertion in the token request have a correct signature",
        "description": "The client_assertion parameter in the token request sent by the RP must be a JWT with a signature",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "jwt check sig": "X_key_core_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'acr_values' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'acr_values' parameter is checked. If it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.acr_values",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'aud' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'aud' parameter is checked. If it missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'exp' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'exp' parameter is checked. If it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'client_id' parameter",
        "description": "In this test the request parameter of the Authentication Request is taken, the payload decrypted and the presence of the 'client_id' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the JWT header of the Authentication Request contain the kid parameter",
        "description": "In this test the request parameter of the Authentication Request is taken, and the presence of the 'kid' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.kid",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'iat' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'iat' parameter is checked. If it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'iss' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'iss' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'nonce' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'nonce' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.nonce",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'prompt' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'prompt' parameter is checked. If it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.prompt",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'redirect_uri' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'redirect_uri' parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.redirect_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'response_type' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'response_type' parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.response_type",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request contain the 'scope' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'scope' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.scope",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'state' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'state' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.state",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'ui_locales' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'ui_locales' parameter is checked. If it is missing, the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.ui_locales",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP's entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration of the RP is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the aud claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the aud claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the exp claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the exp claim is present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the iat claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the iat claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the JWT payload contain 'iss' claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the iss claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the jti claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the jti claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the sub claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the sub claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the JWT payload contain a correct sub claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking the sub claim. Its value must be the same of the iss value",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "saved_iss"
                  }
                ],
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "saved_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the RP checks that the state parameter in an authentication response is the same of the authentication request",
            "description": "In order to check if the RP correctly handles an authentication response, an incorrect response is sent and the behavior of the RP is analyzed. In particular, theflow should be interrupted if the value of the 'state' parameter in the Authentication response does not correspond to the one of the Authentication request.",
            "type": "active",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "session": "s1",
                "action": "start"
              },
              {
                "action": "intercept",
                "from session": "s1",
                "then": "forward",
                "message type": "Authentication response",
                "edit operations": [
                  {
                    "from": "head",
                    "edit regex": "(?<=state=)[^&]+",
                    "value": "incorrect_value_of_state"
                  }
                ]
              }
            ],
            "result": "incorrect flow s1"
          }
        }
      ]
    },
    {
      "test": {
        "name": "Does the RP metadata contain incorrect 'id_token_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_signed_response_alg' parameter is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_signed_response_alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain incorrect 'userinfo_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'userinfo_encrypted_response_alg' parameter is checked. It must not contain the value ['RSA_1_5'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_alg",
                    "is not in": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain incorrect 'userinfo_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'userinfo_signed_response_alg' parameter is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_signed_response_alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain incorrect 'id_token_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_encrypted_response_alg' parameter is checked. It must not contain the value ['RSA_1_5'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_alg",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct type token",
        "description": "The Introspection request made by the RP is taken and the type of the token parameter is a JWT",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "check regex": "token=([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)(?:&|$)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct type of client assertion",
        "description": "The Revocation request made by the RP is taken and the value of the client_assertion parameter is a signed JWT structure",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check regex": "client_assertion=([\\w]+)\\.([\\w]+)\\.([\\w\\-]*)(?:&|$)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct type of token for which the request is made",
        "description": "The Revocation request made by the RP is taken and the value of the token parameter is a JWT.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check regex": "token=([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)(?:&|$)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_assertion in the token request contain a JWT",
        "description": "The client_assertion parameter in the token request sent by the RP must be a JWT",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check regex": "client_assertion=([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)(?:&|$)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request use HTTP POST",
        "description": "The token request sent by the RP must be sent in HTTP POST",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "head",
                "check regex": "POST",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP contain a valid Access Token in the UserInfo request",
        "description": "The UserInfo request from the RP is taken and analyzed. In the Authorization field of the head there must be a valid Access Token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo request",
            "checks": [
              {
                "in": "head",
                "check regex": "Authorization:\\s?Bearer\\s?([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct type of client id of the RP making the request",
        "description": "The Introspection request made by the RP is taken and the value of the client_id parameter is an URI",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "check": "$",
                "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"client_id\"]}"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct type of client_id of the RP making the request",
        "description": "The Revocation request made by the RP is taken and the value of the client_id parameter is an URI that identifies the RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check": "$",
                "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"client_id\"]}"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_id in the token request contain an HTTPS URL",
        "description": "The client_id parameter in the URL of the token request is taken and checked to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check": "$",
                "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"client_id\"]})"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'state' parameter greater than 32 characters",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'state' parameter must be at least 32 alphanumeric characters long. If it is not present or its length is less than 32 alphanumeric characters, then the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"state\": {\"type\": \"string\", \"pattern\": \"^[\\u0020-\\u007E]{32,}$\"}}, \"required\": [\"state\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'nonce' parameter longer than 32 characters",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'nonce' parameter must be at least 32 alphanumeric characters long.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"nonce\": {\"type\": \"string\", \"pattern\": \"^[\\u0020-\\u007E]{32,}$\"}}, \"required\": [\"nonce\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type of 'client_id' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'client_id' parameter is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"client_id\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type grant_types claim",
        "description": "In this test the RP metadata are taken and the 'grant_types' parameter is a JSON array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"grant_types\":{\"type\":\"array\"}}, \"requirement\":[\"grant_type\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain 'grant_types' parameter with value of authorization_code or refresh_token",
        "description": "In this test the RP metadata are taken and the type of the 'grant_types' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"grant_types\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\", \"refresh_token\"]}}},\"required\": [\"grant_types\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type logo_uri claim",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^(https?://).*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain an HTTPS 'redirect_uris' parameter",
        "description": "In this test the RP metadata are taken and the type of the 'redirect_uris' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"redirect_uris\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"format\": \"uri\",\"pattern\": \"^https://.*$\"}}},\"required\": [\"redirect_uris\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'response_types' parameter as a json",
        "description": "In this test the RP metadata are taken and the 'response_types' parameter in the 'openid_relying_party' is a JSON array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"response_types\": {\"type\": \"array\"}}, \"required\": [\"response_types\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP's entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration of the RP is taken, the payload is decoded (Base64 encoding) and the trust_marks parameter is checked, it must be a JSON array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"array\"}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain a correct aud claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking the aud. Its value must be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"aud\": {\"type\": \"array\", \"format\": \"uri-reference\"}}, \"required\": [\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain a correct exp claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking the exp claim. Its value must be a timestap",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain a correct iat claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking the iat claim. Its value must be a timestap",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response RP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response RP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response RP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response RP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response RP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_key_RP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct value of 'client_id' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'client_id' parameter is an HTTPS URL  that uniquely identifies the RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_id",
                    "is": "x_https_RP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the contacts parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'contacts' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the federation_fetch_endpoint parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'federation_fetch_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_fetch_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the federation_list_endpoint parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'federation_list_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_list_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the federation_resolve_endpoint parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'federation_resolve_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the federation_trust_mark_status_endpoint parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'federation_trust_mark_status_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the homepage_uri parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'homepage_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the logo_uri parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'logo_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the organization_name parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'organization_name' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the policy_uri parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'policy_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "This test can be performed by taking the JWT present in the Entity Statement Response, base64url decoding the payload and checking the iss claim. Its value must be an URL identifying the SA",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "This test can be performed by taking the JWT present in the Entity Statement Response, base64url decoding the payload and checking the iss claim. Its value must be an URL identifying the SA",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a list",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"fiscal_number\": {}, \"vat_number\":{}},\"anyOf\":[{\"required\":[\"fiscal_number\"]},{\"required\":[\"vat_number\"]}]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \", \"enum \": [ \"private \", \u00a0\"public \"]}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain a correct sa_profile claim",
        "description": "A Trust Mark issued for an SA is taken, decrypted and the value of the sa_profile claim can be 'full' or 'light'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"sa_profile\": { \"type \": \u00a0\"string \", \"enum \": [ \"full \", \u00a0\"light \"]}}, \"required \": [ \"sa_profile \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a list",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"fiscal_number\": {}, \"vat_number\":{}},\"anyOf\":[{\"required\":[\"fiscal_number\"]},{\"required\":[\"vat_number\"]}]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \", \"enum \": [ \"private \", \u00a0\"public \"]}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain a correct sa_profile claim",
        "description": "A Trust Mark issued for an SA is taken, decrypted and the value of the sa_profile claim can be 'full' or 'light'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"sa_profile\": { \"type \": \u00a0\"string \", \"enum \": [ \"full \", \u00a0\"light \"]}}, \"required \": [ \"sa_profile \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_SA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly signs the Entity Statement",
        "description": "In order to validate the signature of an Entity statement issued by an SA, the statement is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter of the Entity Statement of the SA issued from the TA), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_SA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly signs the Entity Statement",
        "description": "In order to validate the signature of an Entity statement issued by an SA, the statement is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter of the Entity Statement of the SA issued from the TA), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_SA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of the SA contain the trust marks",
        "description": "The entity configuration of the SA is taken from its own web endpoint '.well-known/openid-federation', and the metadata in the response are analyzed. Among them, the 'trust_marks' parameter must be present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the metadata_policy parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the metadata_policy parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sa_profile",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sa_profile",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request entity's endpoint. An HTTP 200 OK response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "body",
                "check regex": "[^\\r\\n]*.^\\{(\\s*\"[^\"]*\"\\s*:\\s*(?:\"[^\"]*\",?|\\[[^\\r\\n]*\\],?|\\{[^\\r\\n]*\\},?)\\s*)*\\}$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly release the Entity statements",
        "description": "After a correct onboarding with the SA, it must publish the entity statement for the subordinate entity in its fetch endpoint. So, in this test, once correctly registered an Entity, an HTTP GET request is made to the SA's fetch endpoint, with the request containing the Entity identifier. The response is then checked and it must contain the subordinate entity's Entity Statement.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "[^\\r\\n]*.^([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly release the Entity statements",
        "description": "After a correct onboarding with the SA, it must publish the entity statement for the subordinate entity in its fetch endpoint. So, in this test, once correctly registered an Entity, an HTTP GET request is made to the SA's fetch endpoint, with the request containing the Entity identifier. The response is then checked and it must contain the subordinate entity's Entity Statement.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "[^\\r\\n]*.^([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Fetch Entity Statement response SA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "[^\\r\\n]*.^([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain correct type logo_uri claim",
        "description": "In this test the SA metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of the SA contain a correct trust_marks parameter",
        "description": "The entity configuration of the SA is taken from its own web endpoint '.well-known/openid-federation', and the configuration metadata are analyzed. Among them, the 'trust_marks' parameter must be present and must be a JSON array containing the Trust Marks.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the SA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the TA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata policy for an RP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the SA, an entity statement for an RP must be fetched in the SA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.jwks",
                    "json schema compliant": "{\"type\":\"object\", \"properties\": {\"value\" :{}}, \"required\": [\"value\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response SA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response SA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response SA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response SA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response SA",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly contain the code parameter on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'code' as query parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check param": "Location",
                "contains": "code"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP contain iss parameter on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'iss' as query parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check param": "Location",
                "contains": "iss"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP contain correct state parameter on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'state' as query parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check param": "Location",
                "contains": "state"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token response have Cache-Control set to 'no-store'",
        "description": "This test verifies the presence of Cache-Control set to 'no-store' in the token response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check param": "Cache-Control",
                "contains": "no-store"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a correct 'alg' parameter in the Header",
        "description": "In this test, the Access Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked. The value must be a supported asymmetric algorithm between ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a wrong 'alg' parameter in the Header",
        "description": "In this test, the Access Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked. If its value is set to none, contains values among ['none', 'HS256', 'HS384', 'HS512'], is absent or contains a symmetric algorithm, than the Access Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a wrong 'alg' parameter in the Header",
        "description": "In this test, the ID Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked. If its value is set to none, contains values among ['none', 'HS256', 'HS384', 'HS512'], is absent or contains a symmetric algorithm, than the ID Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with an aud parameter that does not contain its identifier",
        "description": "The aud parameter identifies subjects of that request. An entity whose identifier is not in the audience of the request should refuse that request. In this test an authorization request is sent to the OP with an aud parameter in the JWT that does not contains its identifier and the response of the OP is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iss",
                    "value": "https://www.example.com/"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the client_id parameter",
        "description": "The 'client_id' parameter in an authentication request's JWT identifies the RP sending the request. In order to test if the OP checks this parameter, an authorization request is sent without the client_id in the JWT and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.client_id",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the code_challenge parameter",
        "description": "The 'code_challenge' parameter in an authentication request is part of the PKCE protocol and is useful against various attacks. In order to test if the OP checks this parameter, an authorization request is sent without the client_id in the JWT and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.code_challenge",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the code_challenge_method parameter",
        "description": "The 'code_challenge_method' parameter in an authentication request says to the OP how to verify the code_challenge when receiving the token request. If one request has a wrong code_challenge_method, than the OP will not be able to verify this parameter. In order to test the OP's behavior, an Authenticaton request is sent without code_challenge_method and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.code_challenge_method",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the nonce parameter",
        "description": "If the nonce in the request is missing, than a control about the freshness of the request/response is missing. In this test an authorization request without the nonce parameter in the JWT is sent and the response analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.nonce",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the scope parameter",
        "description": "An Authentication Request is sent without the scope parameter in JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.scope",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the state parameter",
        "description": "The state parameter identifies the session in the RP side, if this value is missing, than no control about the session is done. In this test an authorization request without the state parameter in the JWT is sent and the response analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.state",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a value of the acr_values parameter wrong or not present in its metadata",
        "description": "In this test an authorization request is sent with a acr_values parameter wrongly set in the JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.acr_values",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a wrong claims parameter",
        "description": "In this test an authorization request is sent with a claims parameter in the JWT which contains not supported values and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.claims",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a value of the code_challenge_method parameter wrong or not present in its metadata",
        "description": "The 'code_challenge_method' parameter in the JWT of an authentication request says to the OP how to verify the code_challenge when receiving the token request. If one request has a wrong code_challenge_method, than the OP will not be able to verify this parameter. In order to test the OP's behavior, an Authenticaton request is sent with a wrong code_challenge_method (a method not present in the OP's metadata) and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.code_challenge_method",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with wrong code_challenge parameter",
        "description": "The 'code_challenge' parameter in an authentication request is part of the PKCE protocol and is useful against various attacks. In order to test if the OP checks this parameter, an authorization request is sent with wrong code_challenge in the JWT and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.code_challenge",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a wrong exp parameter",
        "description": "In this test an authorization request with the exp parameter expired in the JWT is sent and the response analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.exp",
                    "value": "1681723540"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a wrong iat parameter",
        "description": "In this test an authorization request with the iat parameter in the JWT set after the current time is sent and the response analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iat",
                    "value": "1681723540"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a nonce parameter shorter than 32 alphanumeric characters",
        "description": "In this test an authorization request with a nonce parameter in the JWT of a length less than 32 alphanumeric characters is sent and the response analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.nonce",
                    "value": "19az"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a wrong prompt parameter",
        "description": "An Authenticaton request is sent with a wrong prompt parameter in the JWT (a value different from 'consent' and 'consent login') and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.prompt",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a value of the response_type parameter wrong or not present in its metadata",
        "description": "An Authentication Request is sent with a response_type parameter in the JWT wrong or not present in the RP's metadata. If the OP refuses the request, than it checks the parameter, otherwise it is not checking it.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.response_type",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "unsupported_response_type"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a value of the scope parameter wrong or not present in its metadata",
        "description": "The scope parameter is used by the OP to check which claims to send in the ID Token and/or at the Introspection endpoint. The allowed values are openid, offline_access, profile and email (and combination of them), different values must trigger an error response. So in this test a request with a wrong scope parameter in the JWT is sent and the response analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.scope",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_scope"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a state parameter shorter than 32 alphanumeric characters",
        "description": "In this test an authorization request with a state parameter in the JWT of a length less than 32 alphanumeric characters is sent and the response analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.state",
                    "value": "19az"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the acr_values parameter",
        "description": "An Authentication Request is sent without the acr_values parameter in JWT and the response analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.acr_values",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the aud parameter",
        "description": "The aud parameter identifies subjects of that request. An entity whose identifier is not in the audience of the request should refuse that request. In this test an authorization request is sent to the OP with an aud parameter that does not contains its identifier and the response of the OP is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.aud",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the claims parameter",
        "description": "An Authentication Request is sent without the claims parameter in JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.claims",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the exp parameter",
        "description": "An Authentication Request is sent without the exp parameter in JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.exp",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the iat parameter",
        "description": "An Authentication Request is sent without the iat parameter in JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iat",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the iss parameter",
        "description": "An Authentication Request is sent without the iss parameter in JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iss",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the prompt parameter",
        "description": "An Authenticaton request is sent without the prompt parameter in the JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.prompt",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the redirect_uri parameter",
        "description": "An Authentication Request is sent without the redirect_uri parameter in JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.redirect_uri",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the response_type parameter",
        "description": "An Authentication Request is sent without the response_type parameter in JWT and the response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.response_type",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse an RP without trusted Trust Marks",
        "description": "In this test the RP sends an authentication request to the OP, which will ask for the RP's Entity Configuration. The RP must send an Entity Configuration without trusted Trust Marks (Trust Marks issued by an entity not present in the Federation Configuration or no Trust Marks) and if the OP's response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.trust_marks",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly validate the trust chain of an RP authentication request",
        "description": "When an OP receives an authentication request, it must proceed with an Entity Configuration request toward the RP. The received Entity Configuration must be verified through the Entity Statement released by a parent entity of the RP and this process must be repeated until the Trust Anchor. In order to verify if the OP validates this trust chain, the authority_hints in the Entity Configuration of the RP could contain wrong values. If the OP validates the request anyway, it is not compliant with the specification",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.authority_hints",
                    "value": "https://www.wrongsite.com/"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly reject an invalid client_id parameter in an intercepted Authentication Request",
        "description": "This test aims to check if the OP checks the correctness of the client_id parameter. The client id value contained must contain an URL identifying the RP, so in this test the Authentication Request is intercepted, the request parameter is decrypted, the client_id in it modified with a random (and invalid) one, the JWT re-encrypted, the signature re-calculated and sent. The OP should check the parameter and, seen that it is an invalid one, refuse the authentication request.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.client_id",
                    "value": "https://www.example.com/"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with a wrong iss parameter",
        "description": "The 'iss' parameter in the JWT of an authentication request says who sent the request. If one request has a wrong iss, than it could be forwarded by a malicious user, so the iss must be checked. In order to test this behavior in the OP, an Authenticaton request is sent with a wrong iss (not the RP's client id) and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iss",
                    "value": "https://www.example.com/"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Request with a wrong redirect URI",
        "description": "Once received an Authentication Request, an OP must check if the provided redirect URI matches one of the redirect uris in the RP metadata. To verify this behavior, an authentication request is sent to the OP with a wrong redirect URI in the JWT in the request parameter ",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.redirect_uri",
                    "value": "https://www.example.com/"
                  },
                  {
                    "jwt sign": "X_key_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of aud of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and remove the aud parameter",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.aud[0]",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of exp of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and remove the exp parameter",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.exp",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of iat of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and remove the iat parameter",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iat",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of iss of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and remove the iss parameter",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iss",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of jti of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and remove the jti parameter",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.jti",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of sub of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and remove the sub parameter",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.sub",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the value of exp of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and modify the exp of it in order to make it wrong",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.exp",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the value of iat of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and modify the iat of it in order to make it wrong",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iat",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the value of iss of the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and modify the sub to make it different from the iss parameter",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.sub",
                    "value": "example"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests without the aud parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) without the aud parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.aud",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests with a wrong aud parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) with a wrong aud parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.aud",
                    "value": "abc"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests without the exp parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) without the exp parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.exp",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests with a wrong exp parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) with a wrong exp parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.exp",
                    "value": "abc"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests without the iat parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) without the iat parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iat",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests with a wrong iat parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) with a wrong iat parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iat",
                    "value": "abc"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests without the iss parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) without the iss parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iss",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests with a wrong iss parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) with a wrong iss parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iss",
                    "value": "abc"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests without the jti parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) without the jti parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.jti",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests without the sub parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) without the sub parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.sub",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse revocation requests with a wrong sub parameter in the client_assertion",
        "description": "A revocation request is made with a client_assetion parameter (JWT) with a wrong sub parameter in it. The response is analyzed; the OP should refuse it",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.sub",
                    "value": "abc"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with a client_assertion parameter not containing iss claim in the JWT return a Token Error response",
        "description": "In this test the Token Request's 'client_assertion' field is set to a wrong JWT. In particular the iss claim is missing.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iss",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with a client_assertion field not containing sub claim in the JWT return a Token Error response",
        "description": "In this test the Token Request's 'client_assertion' field is set to a wrong JWT. In particular the sub claim is missing",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.sub",
                    "value": ""
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with a client_assertion parameter containing a wrong aud claim not containing the OP's Token endpoint in JWT return a Token Error response",
        "description": "In this test the Token Request's 'client_assertion' field is set to a wrong JWT. In particular the aud claim does not contain the OP's Token endpoint",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.aud",
                    "value": "https://www.example.com"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with a client_assertion parameter containing a wrong exp claim in the JWT return a Token Error response",
        "description": "In this test the Token Request's 'client_assertion' field is set to a wrong JWT. In particular, the exp claim is wrong",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.exp",
                    "value": "1681716340"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with a client_assertion parameter containing a wrong iat claim in the JWT return a Token Error response",
        "description": "In this test the Token Request's 'client_assertion' field is set to a wrong JWT. In particular, the iat claim is wrong",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iat",
                    "value": "1681716340"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with a client_assertion parameter containing a wrong iss claim in the JWT return a Token Error response",
        "description": "In this test the Token Request's 'client_assertion' field is set to a wrong JWT. In particular the iss claim is not set to the RP's client ID",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.iss",
                    "value": "https://www.example.com/"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with a client_assertion parameter containing a wrong sub claim in the JWT return a Token Error response",
        "description": "In this test the Token Request's 'client_assertion' field is set to a wrong JWT. In particular the sub claim is not set to the RP's client ID",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt edit": "$.sub",
                    "value": "https://www.example.com"
                  },
                  {
                    "jwt sign": "X_key_core_RP"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the jwks claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'jwks' parameter in the 'openid_provider' subclaim (metadata type) is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the acr_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'acr_values_supported' in the 'openid_provider' subclaim (metadata type) parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.acr_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the authorization_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'authorization_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.authorization_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the authorization_response_iss_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the authorization_response_iss_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.authorization_response_iss_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the claims_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the claims_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.claims_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the claims_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the claims_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.claims_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the client_registration_types_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the client_registration_types_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.client_registration_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the code_challenge_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'code_challenge_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.code_challenge_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the contacts claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the grant_types_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'grant_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.grant_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the homepage_uri claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the id_token_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'id_token_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the id_token_encryption_enc_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'id_token_encryption_enc_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_enc_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the id_token_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'id_token_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the introspection_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'introspection_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.introspection_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the issuer parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'issuer' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.issuer",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the logo_uri claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the organization_name claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the policy_uri claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the request_authentication_methods_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_authentication_methods_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the request_authentication_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_authentication_signing_alg_values_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the request_object_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'request_object_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_object_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the request_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the response_modes_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'response_modes_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.response_modes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the response_types_supported claim",
        "description": "In this test the OP metadata are taken and the presence of the 'response_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.response_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the revocation_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'revocation_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.revocation_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the revocation_endpoint_auth_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'revocation_endpoint_auth_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.revocation_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the scopes_supported claim",
        "description": "In this test the OP metadata are taken and the presence of the 'scopes_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.scopes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the subject_types_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'subject_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.subject_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the token_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'token_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the token_endpoint_auth_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'token_endpoint_auth_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the token_endpoint_auth_signing_alg_values_supported claim in the 'op' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the userinfo_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'userinfo_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the userinfo_encryption_enc_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'userinfo_encryption_enc_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_enc_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the userinfo_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'userinfo_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the userinfo_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'userinfo_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the jwks or signed_jwks_uri claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'jwks' or the 'signed_jwks_uri' parameter in the 'openid_provider' subclaim (metadata type) is checked. There must be at least one of the two",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.signed_jwks_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'iss' parameter in the Payload equals to the URL of the OP",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the value of the 'iss' parameter is checked equals to the URL of the OP",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "saved_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "saved_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct cty parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response is taken and analyzed. If it contains the 'cty' parameter set to 'JWT' in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.cty",
                    "is": "JWT"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Content-Type of the UserInfo response set to 'application/jwt'",
        "description": "The Content-Type of the UserInfo response must be set to 'application/jwt' ",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct acr_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'acr_values_supported' in the 'openid_provider' subclaim (metadata type) parameter is checked to be [https://www.spid.gov.it/SpidL1, https://www.spid.gov.it/SpidL2, https://www.spid.gov.it/SpidL3]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.acr_values_supported[0]",
                    "is in": [
                      "https://www.spid.gov.it/SpidL1",
                      "https://www.spid.gov.it/SpidL2",
                      "https://www.spid.gov.it/SpidL3"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of client_registration_types_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the client_registration_types_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.client_registration_types_supported[0]",
                    "is in": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct code_challenge_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'code_challenge_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be 'S256'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.code_challenge_methods_supported[0]",
                    "is in": [
                      "S256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct grant_types_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'grant_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be [refresh_token, authorization_code]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.grant_types_supported[0]",
                    "is in": [
                      "refresh_token",
                      "authorization_code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct id_token_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_alg_values_supported[0]",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct id_token_encryption_enc_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_encryption_enc_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_enc_values_supported[0]",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct id_token_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain a correct issuer parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'issuer' parameter in the 'openid_provider' subclaim (metadata type) is checked to be the URL of the OP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.issuer",
                    "is in": [
                      "X_url_OP"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct request_authentication_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the request_authentication_signing_alg_values_supported claim in the 'openid_provider' entity type is checked to ['RS256', 'RS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct request_object_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'request_object_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_object_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct response_modes_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'response_modes_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be [form_post, query]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.response_modes_supported[0]",
                    "is in": [
                      "form_post",
                      "query"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct response_types_supported claim",
        "description": "In this test the OP metadata are taken and the presence of the 'response_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present and must be set to 'code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.response_types_supported[0]",
                    "is in": [
                      "code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct revocation_endpoint_auth_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'revocation_endpoint_auth_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is 'private_key_jwt'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.revocation_endpoint_auth_methods_supported",
                    "is in": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct scopes_supported claim",
        "description": "In this test the OP metadata are taken and the value of the 'scopes_supported' parameter in the 'openid_provider' subclaim (metadata type) is [openid, offline_access, profile, email]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.scopes_supported[0]",
                    "is in": [
                      "openid",
                      "offline_access",
                      "profile",
                      "email"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct subject_types_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'subject_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is 'pairwise'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.subject_types_supported[0]",
                    "is in": [
                      "pairwise"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of token_endpoint_auth_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'token_endpoint_auth_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_methods_supported[0]",
                    "is in": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the token_endpoint_auth_signing_alg_values_supported claim in the 'openid_provider' entity type is checked to be ['RS256', 'RS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct userinfo_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_alg_values_supported[0]",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct userinfo_encryption_enc_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_encryption_enc_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_enc_values_supported[0]",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct userinfo_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain correct value of 'acr' parameter valid in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'acr' parameter in the Payload is checked. Its value is one of ['https://www.spid.gov.it/SpidL1', 'https://www.spid.gov.it/SpidL2', 'https://www.spid.gov.it/SpidL3']. It must be equal or superior to the acr send from the RP in the Authentication Request.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.acr",
                    "is in": [
                      "https://www.spid.gov.it/SpidL1",
                      "https://www.spid.gov.it/SpidL2",
                      "https://www.spid.gov.it/SpidL3"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the active parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must contain the 'active' parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "active"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint returns true on active tokens",
        "description": "To test that the Introspection response of the OP's correctly identifies valid tokens, a valid one is sent and the response is analyzed",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "\"active\": true"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the HTTP method of the Revocation request",
        "description": "The revocation request must be sent via HTTP POST",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "POST"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain access token",
        "description": "The Token response is analyzed and the presence of the access token is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "access_token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP issue the access tokens when requested",
        "description": "In this test an authentication request with scope 'openid' is made. Once received the code, the RP tries to exchange it in the token endpoint and the response must contain the access token.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "access_token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP issue the expires_in in a token response",
        "description": "In this test an RP makes a correct authentication request and, once received the code, the RP tries to exchange it in the token endpoint. The response is then analyzed and it must contain the expires_in parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "expires_in"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain the ID token",
        "description": "The RP receiving the Token response and that sent a correct token request must check the presence of the ID token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "id_token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain the token type",
        "description": "The RP receiving the Token response and that sent a correct token request must check the presence of the token type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "token_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the HTTP status code of the UserInfo response is 200",
        "description": "A correct UserInfo request is made to the UserInfo endpoint (it must contain the parameter Authorization: Bearer <token> in the header) and the response analyzed. The HTTP code must be 200",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "head",
                "is present": true,
                "check param": "HTTP/?\\d?\\.?\\d?\\s200"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Content-Type in a token response set correctly?",
        "description": "This test verifies the head Content-Type set to application/json in the token response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check": "Content-Type",
                "is": "application/json"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token_type of a token response set correctly?",
        "description": "This test verifies whether the token_type of a token response is Bearer.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check": "token_type",
                "is": "Bearer"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the revocation endpoint return an empty HTTP 200 OK response upon a correct revocation request",
        "description": "A correct flow is accomplished and, once received the token, a request is made to the revocation endpoint. The response is then analyzed and has to be an empty HTTP 200 OK",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP handle a correct token request",
        "description": "In this test a normal flow is accomplished and is tried to obtain an Access Token. All requests are well-formed and the Responses of the OP are analyzed.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the HTTP status of a token response correct?",
        "description": "This test verifies whether the HTTP status of a token response is 200.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests signed with a non-asymmetric method",
        "description": "This test aims to check if the OP correctly handles the signature of the Authentication request: If the OP is not able to decrypt the signature, than the public key of the RP is wrong or, otherwise, the algorithm used is not known. If, instead, the OP is able to decrypt the signature, it can mean that the public key is correct and the algorithm known, or that the RP used a symmetric algorithm and the RP's key is the same key used to sign the JWT. In the latter case the confidentiality and integrity of the message cannot be trusted. In this case, the OP must check the 'alg' parameter in the JWT Header and, if it corresponds to a symmetric algorithm or to 'none', it must refuse the authentication request. In order to accomplish this test, a crafted RP could set in its metadata a symmetric key, use it to sign the JWT and send an Authentication Request. Another way to accomplish the test is by intercepting the request, changing the parameter and the signature.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "header",
                    "jwt edit": "alg",
                    "value": "none"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain the alg parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response's body is taken and analyzed. If it contains the 'alg' parameter in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain the cty parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response's body is taken and analyzed. If it contains the 'cty' parameter in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.cty",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain the enc parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response's body is taken and analyzed. If it contains the 'enc' parameter in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain the kid parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response's body is taken and analyzed. If it contains the 'kid' parameter in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.kid",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with the scope parameter different in the URL and in the JWT",
        "description": "The Authentication Request is intercepted and the scope parameter in the URL is modified to a valid value but different from the scope parameter in the JWT payload that can be found in the request query parameter. The same parameter in the JWT's payload is left unchanged.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "edit operations": [
              {
                "from": "url",
                "value": "openid",
                "edit": "scope"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the request parameter",
        "description": "The 'request' parameter in an authentication request is crucial to authenticate and answer correctly. If a request is missing the request parameter, than the OP should refuse it. In order to test the OP's behavior, an Authenticaton request is sent without request parameter in the URL and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "edit operations": [
              {
                "from": "url",
                "value": "",
                "edit": "request"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests without the scope parameter in the URL",
        "description": "An Authentication Request is sent without the scope parameter in the URL of the request (scope in the HTTP request)",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "edit operations": [
              {
                "from": "url",
                "value": "",
                "edit": "scope"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse Authentication Requests with the request parameter that is not a JWT",
        "description": "The 'request' parameter in an authentication request is crucial to authenticate and answer correctly. If a request has a request parameter, that is not a JWT, it means that the OP should refuse it. In order to test the OP's behavior, an Authenticaton request is sent with a random value in the request parameter in the URL and the answer is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "edit operations": [
              {
                "from": "url",
                "value": "example",
                "edit": "request"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP accept introspection requests without the client assertion",
        "description": "A request to the introspection endpoint is made without the client assertion in it. The OP's response is analyzed",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_assertion=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP accept introspection requests without the client assertion type",
        "description": "An introspection request without the client_assertion_type parameter is sent and the response analyzed",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_assertion_type=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP accept introspection requests without the client id",
        "description": "To test if an OP verifies the presence of the client id of the RP in the Introspection request, a request without the client id is sent and the response is analyzed.",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_id=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "How does the OP behave when receiving an introspection request without the token",
        "description": "An introspection request without a token is sent and the introspection response analyzed",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=token=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP accept introspection requests with a wrong client assertion type",
        "description": "An introspection request with a wrong value in the client_assertion_type parameter is sent and the response analyzed",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "edit operations": [
              {
                "from": "body",
                "value": "X_wrong_value",
                "edit regex": "(?<=client_assertion_type=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the client id of the Introspection Request",
        "description": "To test if an OP verifies the presence of the client id of the RP in the Introspection request, a request with a wrong client id (not present in the federation) is sent and the response is analyzed.",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "edit operations": [
              {
                "from": "body",
                "value": "https://www.example.com/",
                "edit regex": "(?<=client_id=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the parameters of the client assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in sending a request with a wrong the parameter in the JWT present in the client_assertion parameter of the request and adapt the signature to make it correct. If the OP accepts the request anyway, then it does not verify the JWT.",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "edit operations": [
              {
                "from": "body",
                "value": "X_wrong_value",
                "edit regex": "(?<=client_assertion=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "How does the OP behave when receiving an introspection request with a wrong token",
        "description": "An introspection request with a token not valid is sent and the introspection response analyzed",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "edit operations": [
              {
                "from": "body",
                "value": "X_not_valid_tkn",
                "edit regex": "(?<=token=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of token in the Revocation request",
        "description": "Since the OP has to verify the client assertion in the Revocation Request, this test consist in intercepting a legitimate request and remove token.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=token=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP accept revocation request without the client assertion",
        "description": "In order to verify if the OP checks the presence of the client_assertion parameter in a revocation request, such a request is sent without the client_assertion and the OP's response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_assertion=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP accept Revocation Requests without the client assertion type",
        "description": "To test if an OP verifies the presence of the client assertion type in the Revocation request, a request withiout client assertion type is sent and the response is analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_assertion_type=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP accept Revocation Requests without the client id",
        "description": "To test if an OP verifies the presence of the client id of the RP in the Revocation request, a request without the client id is sent and the response is analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_id=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the client assertion type of the Revocation Request",
        "description": "To test if an OP verifies the client assertion type in the Revocation request, a request with a wrong client_assertion_type parameter is sent and the response is analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "edit operations": [
              {
                "from": "body",
                "value": "urn-ietf",
                "edit regex": "(?<=client_assertion_type=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the client id of the Revocation Request",
        "description": "To test if an OP verifies the presence of the client id of the RP in the Revocation request, a request with a wrong client id (not present in the federation) is sent and the response is analyzed.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "edit operations": [
              {
                "from": "body",
                "value": "https://www.example.com/",
                "edit regex": "(?<=client_id=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made without the client_assertion parameter return a Token Error response",
        "description": "This test consists in sending a token request without the client_assertion parameter and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_assertion=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made without the client_assertion_type parameter return a Token Error response",
        "description": "This test consists in sending a token request without the client_assertion_type parameter and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_assertion_type=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP require the client_id in the token request",
        "description": "This test consists in sending a token request without the client_id parameter and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_id=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s401"
              },
              {
                "in": "body",
                "check": "invalid_client"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made without the code parameter return a Token Error response",
        "description": "This test consists in sending a token request without the code parameter and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=code=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_grant"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made without the code_verifier parameter return a Token Error response",
        "description": "This test consists in sending a token request without the code_verifier parameter and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=code_verifier=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_grant"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made without the grant_type parameter return a Token Error response",
        "description": "This test consists in sending a token request without the grant_type parameter and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=grant_type=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP check the client_id in the request",
        "description": "In this test the client_id parameter in the URL of the token request is removed and the response analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "",
                "edit regex": "(?<=client_id=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with an incorrect client_assertion_type parameter return a Token Error response",
        "description": "This test consists in sending a token request with a wrong client_assertion_type parameter and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "urn-aert",
                "edit regex": "(?<=client_assertion_type=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with an incorrect code parameter (i.e., not belonging to that client ID or a random code) return a Token Error response",
        "description": "This test consists in sending a token request with a wrong code parameter (thus not for that client ID or a random code) and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "X_wrong_code",
                "edit regex": "(?<=code=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_grant"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with an incorrect code_verifier parameter return a Token Error response",
        "description": "This test consists in sending a token request with a wrong code_verifier parameter and analyzing the token response. The response must be a Token Error response.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "X_wrong_code",
                "edit regex": "(?<=code_verifier=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the OP checks that the token request contains the grant_type parameter set correctly",
        "description": "In order to validate if the OP checks the token request sent by the RP, in this test we send the grant_type parameter in the request set to and invalid value, just like 'example' and analyze the response",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "edit operations": [
              {
                "from": "body",
                "value": "example",
                "edit regex": "(?<=grant_type=)([^&]+)"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "unsupported_grant_type"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "How does the OP behave when the token in the userinfo request is missing",
        "description": "A userinfo request without the 'Authorization: Bearer ...' field is made and the response analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "UserInfo request",
            "edit operations": [
              {
                "from": "head",
                "value": "",
                "edit": "Authorization"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "assert_only"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'client_id' parameter in the Payload and identify the client",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'client_id' parameter in the Payload must identify the client issuing the request",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "message operations": [
              {
                "from": "url",
                "save": "client_id",
                "as": "auth_client_id"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "client_id",
                    "is": "auth_client_id",
                    "use variable": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a correct 'scope' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the 'scope' parameter in the Payload is checked, in particular, its value MUST match the value in the authentication request.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "message operations": [
              {
                "from": "url",
                "save": "scope",
                "as": "auth_scope"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "scope",
                    "is": "auth_scope",
                    "use variable": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly sign the Access Token",
        "description": "Tokens issued by an OP must have the structure of JWT Tokens. In particular, this structure is composed by three base64url encoded strings separated by dots, namely the header, payload and signature. The signature is made using the OP's private key, in such a way to be decrypted using its public key. In this test a normal flow is performed and the obtained Access Token is analyzed. In order to test if the OP correctly signed the signature part of the JWT, the access token is passed to a signature verifier correctly configured",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "jwt check sig": "X_key_core_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly sign the ID Token",
        "description": "Tokens issued by an OP must have the structure of JWT Tokens. In particular, this structure is composed by three base64url encoded strings separated by dots, namely the header, payload and signature. The signature is made using the OP's private key, in such a way to be decrypted using its public key. In this test a normal flow is performed and the obtained ID Token is analyzed. In order to test if the OP correctly signed the signature part of the JWT, the third part of the string is taken and passed to a signature verifier correctly configured",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "jwt check sig": "X_key_core_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain the authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the presence of the authority_hints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.authority_hints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'alg' parameter in the Header",
        "description": "In this test, the Access Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'kid' parameter in the Header",
        "description": "The Access Token is taken from the Token Response and the presence of the 'kid' parameter in the Header is checked. If it is not present, than the Access Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.kid",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'typ' parameter in the Header",
        "description": "The Access Token present in the Token response is analyzed and the presence of the 'typ' parameter in the header is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.typ",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'aud' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'aud' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'client_id' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'client_id' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'exp' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'exp' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'iat' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'iat' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'iss' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'iss' parameter in the Payload is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'jti' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'jti' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'scope' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'scope' parameter in the Payload is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.scope",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'sub' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'sub' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'alg' parameter in the Header",
        "description": "In this test, the ID Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'kid' parameter in the Header",
        "description": "The ID Token is taken from the Token Response and the presence of the 'kid' parameter in the Header is checked. If it is not present, than the ID Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.kid",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'acr' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'acr' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.acr",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does ID token payload contain the 'at_hash' parameter",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'at_hash' parameter in the Payload is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.at_hash",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'aud' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'aud' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'exp' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'exp' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'iat' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'iat' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'iss' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'iss' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'jti' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'jti' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'nonce' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'nonce' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.nonce",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'sub' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'sub' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct alg parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response is taken and analyzed. If it contains the 'alg' parameter containing a value among ['RSA-OAEP', 'RSA-OAEP-256', 'ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A256KW'] in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256",
                      "ECDH-ES",
                      "ECDH-ES+A128KW",
                      "ECDH-ES+A256KW"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct enc parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response is taken and analyzed. If it contains the 'enc' parameter containing a value among ['A128CBC-HS256', 'A256CBC-HS512'] in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.enc",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's revocation endpoint answer correctly when a non-existing token is provided",
        "description": "A request to the Revocation endpoint containing a non-existing token is sent and the response analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "message operations": [
              {
                "from": "body",
                "edit": "(?<=token=)([^&]+)",
                "in": "123.123.123"
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct alg parameter in the JOSE Header",
        "description": "In this test, the JWE is taken from the Userinfo Response's body, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked. If its value is set to none, contains values among ['none', 'HS256', 'HS384', 'HS512'], is absent or contains a symmetric algorithm, than the Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP issue refresh tokens even when it is not supposed to",
        "description": "In this test an RP makes an authentication request with an arbitrary scope that differs from 'offline_access'. Once received the code, the RP tries to exchange it in the token endpoint and the response must not contain the refresh token.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check": "refresh_token",
                "is present": false
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP refuse wrongly signed Authentication Requests",
        "description": "This test aims to check if the OP correctly handles the signature of the Authentication request: once received the request, the JWT token must be split in its 3 parts (header, payload, signature), base64url decoded and the signature must be verified. In order to test if the OP really checks the signature, the Authentication request is intercepted before arriving to the OP and the signature is changed. If the OP grants the tokens anyway, than it did not check the signature.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "edits": [
                  {
                    "jwt sign": "X_wrong_key"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Authentication error response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s302"
              },
              {
                "in": "head",
                "check": "unauthorized_client"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the signature of the client assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and modify the signature of it in order to make it wrong. If the OP Accepts the request anyway, than it does not verify the signature of the assertion.",
        "type": "active",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "session": "s_CIE_introsp",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt sign": "X_wrong_key"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s_CIE_introsp",
            "then": "forward",
            "message type": "Introspection response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the signature of the client assertion in the Revocation request",
        "description": "Since the OP has to verify the client assertion in the Revocation Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and modify the signature of it in order to make it wrong. If the OP Accepts the request anyway, than it does not verify the signature of the assertion.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt sign": "X_wrong_key"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token response to a token request made with a wrong signature return a Token Error response",
        "description": "In this test a classic flow is accomplished and, when exchanging the code for an access token, the client_assertion parameter is taken and the signature is substitute with a wrong one. The OP's response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt sign": "X_wrong_key"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's token endpoint refuse assertions signed with a wrong key",
        "description": "In this test a classic flow is accomplished and, when exchanging the code for an access token, the signature is done with a wrong key. The OP's response is analyzed",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "edits": [
                  {
                    "jwt sign": "X_wrong_key"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s400"
              },
              {
                "in": "body",
                "check": "invalid_request"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain an incorrect id_token_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_alg_values_supported",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect id_token_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect request_authentication_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the request_authentication_signing_alg_values_supported claim in the 'openid_provider' entity type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_signing_alg_values_supported[0]",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect request_object_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'request_object_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_object_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the token_endpoint_auth_signing_alg_values_supported claim in the 'openid_provider' entity type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect userinfo_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the values ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_alg_values_supported",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect userinfo_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP contain the correct type of code parameter on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'code' as query parameter and it must be a UUID.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check regex": "(?<=code=)[a-zA-Z0-9]+(?=&)",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain a valid access token",
        "description": "In this test a correct Token request is sent and the response is analyzed. It must contain the access token parameter and its value must be a JWT",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check regex": "(?<=\"access_token\":\\s?)\"([\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+)\"",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain a valid ID token",
        "description": "The RP receiving the Token response and that sent a correct token request must check the presence of a valid ID token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check regex": "(?<=\"id_token\":\\s?)\"([\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+)\"",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Endpoint create a signed and encrypted JWT",
        "description": "The UserInfo response is taken and the presence of a signed and encrypted JWE in the body of the response is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+$",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\"}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type issuer parameter",
        "description": "In this test the OP metadata are taken and the 'issuer' parameter in the 'openid_provider' subclaim (metadata type) is checked to be an URL with no query or fragment component",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"issuer\":{\"type\":\"string\", \"format\":\"uri\"}},\"required\":[\"issuer\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type logo_uri claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\": \"^(https?://).*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of request_authentication_methods_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_authentication_methods_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"additionalProperties\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"const\": \"request_object\"}}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the trust_marks parameter is checked, it must be a JSON array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a correct 'aud' parameter",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'aud' parameter in the Payload is the identifier of the resource server",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"aud\":{\"type\":\"array\"}},\"required\":[\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'client_id' parameter in the Payload as an HTTPS url",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'client_id' parameter in the Payload must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"client_id\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"client_id\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a timestamp as the 'exp' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'exp' parameter in the Payload is checked. In particular, this parameter must be a valid timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a correct 'iat' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'iat' parameter in the Payload is a timestamp.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token's 'iss' parameter contain an URL",
        "description": "The Access Token present in the Token Response is analyzed and the 'iss' parameter in the Payload is checked, in particular, its value must be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'jti' parameter in the Payload in uuid4 format",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'jti' parameter in the Payload must be based on uuid4 format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"jti\": {\"type\": \"string\", \"pattern\": \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"}}, \"required\": [\"jti\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'exp' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the type of the 'exp' parameter in the Payload is checked. In particular, its value must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=id_token: \")([^\"]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'iat' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'iat' parameter in the Payload is checked. In particular, its value must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=id_token: \")([^\"]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'iss' parameter in the Payload as an HTTPS URL",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'iss' parameter has to be an HTTPS URL identifying the OP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"const\": \"X_https_OP\"}}, \"required\":[\"iss\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'sub' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the 'sub' parameter is checked to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"pattern\": \"^[0-9a-f]{64}$\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response OP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response OP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response OP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response OP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test suite": {
        "name": "Single test",
        "description": "One test only",
        "filter messages": true
      },
      "tests": [
        {
          "test": {
            "name": "Does the metadata parameter contain only allowed types and only once for each",
            "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
            "type": "passive",
            "sessions": [
              "s1"
            ],
            "operations": [
              {
                "message type": "Entity Configuration response OP",
                "decode operations": [
                  {
                    "from": "body",
                    "decode param": "[^\\n\\r]*",
                    "type": "jwt",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$.metadata",
                        "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                      }
                    ]
                  }
                ]
              }
            ],
            "result": "correct flow s1"
          }
        }
      ]
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_key_OP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of authorization_response_iss_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the authorization_response_iss_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.authorization_response_iss_parameter_supported.value",
                    "is": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of claims_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the claims_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.claims_parameter_supported.value",
                    "is": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of request_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_parameter_supported.value",
                    "is": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    }
  ]
}